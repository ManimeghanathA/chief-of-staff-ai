codes:

C:\Users\manim\OneDrive\Desktop\chief-of-staff-ai:

/backend:
/app:
/agent:
graph.py:
from langgraph.graph import StateGraph, END
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_core.messages import SystemMessage, HumanMessage

from app.agent.schemas import AgentState
from app.agent.memory import load_user_memory, save_user_memory
from app.tools.calendar_read_tool import fetch_upcoming_events
from app.tools.gmail_read_tool import fetch_gmail_messages_for_date


from datetime import datetime, timedelta
import json

llm = ChatGoogleGenerativeAI(
    model="gemini-2.5-flash",
    temperature=0
)

# ---------- MEMORY ----------
def load_memory_node(state: AgentState, config):
    db = config["configurable"]["db"]
    state.memory = load_user_memory(db, state.user_id)
    return state

# -------- re helper function --------
import re
from datetime import datetime, timedelta

def extract_time_range(text: str):
    """
    Extracts simple time ranges like:
    'from 10 to 11'
    '10am to 11am'
    Returns (start_datetime, end_datetime) or (None, None)
    """

    match = re.search(r"from (\d{1,2})\s*(am|pm)?\s*to\s*(\d{1,2})\s*(am|pm)?", text)
    if not match:
        return None, None

    start_hour = int(match.group(1))
    end_hour = int(match.group(3))

    # basic AM/PM handling
    if match.group(2) == "pm" and start_hour < 12:
        start_hour += 12
    if match.group(4) == "pm" and end_hour < 12:
        end_hour += 12

    today = datetime.utcnow()

    start_time = today.replace(hour=start_hour, minute=0, second=0)
    end_time = today.replace(hour=end_hour, minute=0, second=0)

    # tomorrow support
    if "tomorrow" in text.lower():
        start_time += timedelta(days=1)
        end_time += timedelta(days=1)

    return start_time, end_time



def intent_router_node(state: AgentState, config):
    text = state.message.lower()

    # -------- CALENDAR INTENTS --------
    if "meeting" in text or "calendar" in text:

        # CREATE MEETING
        if "create" in text or "schedule" in text:
            state.intent = "calendar_create"

            # â± Extract time range if present
            start, end = extract_time_range(state.message)
            state.start_time = start
            state.end_time = end

            return state

        # READ MEETINGS
        if "today" in text:
            state.intent = "calendar_today"
            return state

        if "tomorrow" in text:
            state.intent = "calendar_tomorrow"
            return state

        # Missing info
        state.intent = "need_more_info"
        return state

    # -------- GMAIL INTENTS --------
    if "mail" in text or "email" in text:

        if "today" in text and ("important" in text or "summary" in text):
            state.intent = "gmail_today_summary"
            return state

        if "today" in text:
            state.intent = "gmail_today"
            return state

        if "yesterday" in text:
            state.intent = "gmail_yesterday"
            return state

        state.intent = "need_more_info"
        return state

    # -------- UNSUPPORTED --------
    state.intent = "unsupported"
    return state



# ---------- CALENDAR TOOL ----------
def calendar_today_node(state: AgentState, config):
    db = config["configurable"]["db"]

    events = fetch_upcoming_events(
        user_id=state.user_id,
        db=db,
        max_results=5
    )

    if not events:
        state.response = "You have no meetings scheduled for today."
        return state

    lines = []
    for e in events:
        start = e["start"].get("dateTime", e["start"].get("date"))
        summary = e.get("summary", "Untitled meeting")
        lines.append(f"- {summary} at {start}")

    state.response = "Here are your meetings today:\n" + "\n".join(lines)
    return state


# ---------- FALLBACK CHAT ----------
def chat_node(state: AgentState, config):
    system_prompt = (
        "You are a Chief-of-Staff AI assistant.\n"
        "If you cannot perform an action, explain politely.\n\n"
        f"User memory: {state.memory}"
    )

    response = llm.invoke([
        SystemMessage(content=system_prompt),
        HumanMessage(content=state.message)
    ])

    state.response = response.content
    return state


# ---------- MEMORY EXTRACTION ----------
def extract_memory_node(state: AgentState, config):
    db = config["configurable"]["db"]

    prompt = (
        "Extract long-term personal facts as JSON.\n"
        "Return [] if none.\n\n"
        f"Message: {state.message}"
    )

    result = llm.invoke([HumanMessage(content=prompt)])

    try:
        content = result.content.strip()
        start = content.find("[")
        end = content.rfind("]") + 1
        facts = json.loads(content[start:end])
        save_user_memory(db, state.user_id, facts)
    except Exception:
        pass

    return state

#------------Calendar tomorrow node-------------
def calendar_tomorrow_node(state: AgentState, config):
    db = config.get("configurable", {}).get("db")

    events = fetch_upcoming_events(
        user_id=state.user_id,
        db=db,
        max_results=5
    )

    tomorrow = (datetime.utcnow() + timedelta(days=1)).date()

    tomorrow_events = []
    for e in events:
        start_raw = e["start"].get("dateTime", e["start"].get("date"))
        start_dt = datetime.fromisoformat(start_raw.replace("Z", "+00:00"))

        if start_dt.date() == tomorrow:
            tomorrow_events.append(e)

    if not tomorrow_events:
        state.response = "You have no meetings scheduled for tomorrow."
        return state

    lines = []
    for e in tomorrow_events:
        start = e["start"].get("dateTime", e["start"].get("date"))
        summary = e.get("summary", "Untitled meeting")
        lines.append(f"- {summary} at {start}")

    state.response = "Here are your meetings tomorrow:\n" + "\n".join(lines)
    return state

# ------------ gmail today ----------
def gmail_today_node(state: AgentState, config):
    db = config.get("configurable", {}).get("db")

    emails = fetch_gmail_messages_for_date(
        user_id=state.user_id,
        db=db,
        days_ago=0
    )

    if not emails:
        state.response = "You didnâ€™t receive any emails today."
        return state

    lines = [
        f"- {e['subject']} (from {e['from']})"
        for e in emails
    ]

    state.response = "Here are the emails you received today:\n" + "\n".join(lines)
    return state

#------------- gmail yesterday ---------
def gmail_yesterday_node(state: AgentState, config):
    db = config.get("configurable", {}).get("db")

    emails = fetch_gmail_messages_for_date(
        user_id=state.user_id,
        db=db,
        days_ago=1
    )

    if not emails:
        state.response = "You didnâ€™t receive any emails yesterday."
        return state

    lines = [
        f"- {e['subject']} (from {e['from']})"
        for e in emails
    ]

    state.response = "Here are the emails you received yesterday:\n" + "\n".join(lines)
    return state

# -------------- gmail today summary -----------
def gmail_today_summary_node(state: AgentState, config):
    db = config.get("configurable", {}).get("db")

    emails = fetch_gmail_messages_for_date(
        user_id=state.user_id,
        db=db,
        days_ago=0,
        max_results=15
    )

    if not emails:
        state.response = "You didnâ€™t receive any emails today."
        return state

    email_text = "\n".join(
        f"From: {e['from']} | Subject: {e['subject']}"
        for e in emails
    )

    prompt = (
        "You are a Chief-of-Staff AI.\n"
        "From the emails below, identify which are important "
        "(work, deadlines, meetings, actions) and summarize them.\n\n"
        f"{email_text}"
    )

    summary = llm.invoke(prompt)
    state.response = summary.content
    return state

from app.tools.calendar_write_tool import create_calendar_event
from datetime import datetime, timedelta

def calendar_create_node(state: AgentState, config):
    db = config.get("configurable", {}).get("db")

    # Safety check (very important)
    if not state.start_time or not state.end_time:
        state.response = (
            "I need the start time and end time to create the meeting. "
            "Please tell me the time."
        )
        return state

    # Default title
    title = "Meeting"

    event = create_calendar_event(
        user_id=state.user_id,
        db=db,
        title=title,
        start_time=state.start_time,
        end_time=state.end_time,
    )

    state.response = (
        f"âœ… Your meeting has been created successfully.\n"
        f"ðŸ—“ {title}\n"
        f"ðŸ”— {event.get('htmlLink')}"
    )

    return state





# ---------- GRAPH ----------
def build_graph():
    graph = StateGraph(AgentState)

    graph.add_node("load_memory", load_memory_node)
    graph.add_node("intent_router", intent_router_node)
    graph.add_node("calendar_today", calendar_today_node)
    graph.add_node("calendar_tomorrow", calendar_tomorrow_node)
    graph.add_node("gmail_today", gmail_today_node)
    graph.add_node("gmail_yesterday", gmail_yesterday_node)
    graph.add_node("gmail_today_summary", gmail_today_summary_node)
    graph.add_node("calendar_create", calendar_create_node)
    graph.add_node("chat", chat_node)
    graph.add_node("extract_memory", extract_memory_node)

    graph.set_entry_point("load_memory")

    graph.add_edge("load_memory", "intent_router")

    graph.add_conditional_edges(
        "intent_router",
        lambda state: state.intent,
        {
            "calendar_today": "calendar_today",
            "calendar_tomorrow": "calendar_tomorrow",
            "calendar_create": "calendar_create", 
            "gmail_today": "gmail_today",
            "gmail_yesterday": "gmail_yesterday",
            "gmail_today_summary": "gmail_today_summary",
            "need_more_info": "chat",
            "unsupported": "chat",
        }
    )


    graph.add_edge("calendar_today", END)
    graph.add_edge("chat", "extract_memory")
    graph.add_edge("extract_memory", END)

    return graph.compile()

intent_schema.py:
from pydantic import BaseModel
from typing import Optional, Literal


class AgentIntent(BaseModel):
    intent: Literal[
        "gmail_today",
        "gmail_yesterday",
        "gmail_today_summary",
        "calendar_today",
        "calendar_tomorrow",
        "calendar_create",
        "unsupported",
        "need_more_info"
    ]

    # For calendar_create
    date: Optional[Literal["today", "tomorrow"]] = None
    start_time: Optional[str] = None
    end_time: Optional[str] = None

    reason: Optional[str] = None

memory.py:
from sqlalchemy.orm import Session
from app.db.models import Memory


def load_user_memory(db: Session, user_id: int):
    memories = db.query(Memory).filter(Memory.user_id == user_id).all()
    return [{"key": m.key, "value": m.value} for m in memories]


def save_user_memory(db: Session, user_id: int, facts: list):
    for fact in facts:
        memory = Memory(
            user_id=user_id,
            key=fact["key"],
            value=fact["value"],
            source="chat"
        )
        db.add(memory)
    db.commit()

schemas.py:
from typing import List, Dict, Optional, Literal
from pydantic import BaseModel
from datetime import datetime

class AgentState(BaseModel):
    user_id: str
    message: str

    # memory
    memory: List[Dict[str, str]] = []

    # intent
    intent: Optional[
        Literal[
            "gmail_today",
            "gmail_yesterday",
            "gmail_today_summary",
            "calendar_today",
            "calendar_tomorrow",
            "calendar_create",
            "need_more_info",
            "unsupported",
        ]
    ] = None

    # calendar fields
    start_time: Optional[datetime] = None
    end_time: Optional[datetime] = None

    # final response
    response: Optional[str] = None


/api:
calendar.py:
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session

from app.db.database import SessionLocal
from app.tools.calendar_read_tool import fetch_upcoming_events

router = APIRouter(prefix="/calendar", tags=["calendar"])


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


from app.auth.dependencies import get_current_user
from app.db.models import User
@router.get("/events")
def get_calendar_events(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):
    try:
        events = fetch_upcoming_events(
            user_id=current_user.id,
            db=db
        )
    except Exception as e:
        # This typically means calendar scope not granted
        raise HTTPException(
            status_code=403,
            detail="Calendar not connected. Please connect your calendar."
        )

    return {
        "count": len(events),
        "events": events
    }

from pydantic import BaseModel
from datetime import datetime
from app.auth.dependencies import get_current_user
from app.db.models import User
from app.tools.calendar_write_tool import create_calendar_event


class CreateEventRequest(BaseModel):
    title: str
    start_time: datetime
    end_time: datetime


@router.post("/create-event")
def create_event(
    payload: CreateEventRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    event = create_calendar_event(
        user_id=current_user.id,
        db=db,
        title=payload.title,
        start_time=payload.start_time,
        end_time=payload.end_time,
    )

    return {
        "message": "Event created successfully",
        "event": event
    }


chat.py:
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from pydantic import BaseModel

from app.db.database import SessionLocal
from app.agent.graph import build_graph
from app.agent.schemas import AgentState
from app.auth.dependencies import get_current_user
from app.db.models import User

router = APIRouter(prefix="/chat", tags=["chat"])


class ChatRequest(BaseModel):
    message: str  # â† ONLY MESSAGE


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@router.post("/")
def chat(
    payload: ChatRequest,
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db),
):
    graph = build_graph()

    state = AgentState(
        user_id=str(current_user.id),
        message=payload.message,
    )

    result = graph.invoke(
        state,
        config={"configurable": {"db": db}}
    )

    # âœ… SAFE handling for LangGraph return type
    if isinstance(result, dict):
        response_text = result.get("response", "")
    else:
        response_text = result.response

    return {"response": response_text}


gmail.py:
from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session

from app.db.database import SessionLocal
from app.tools.gmail_tool import fetch_latest_emails

router = APIRouter(prefix="/gmail", tags=["gmail"])


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


from app.auth.dependencies import get_current_user
from app.db.models import User

@router.get("/latest")
def get_latest_emails(
    current_user: User = Depends(get_current_user),
    db: Session = Depends(get_db)
):

    emails = fetch_latest_emails(
        user_id=current_user.id,
        db=db
    )

    return {
        "count": len(emails),
        "emails": emails
    }

/auth
auth_utils:
from datetime import datetime, timedelta
from jose import jwt
from passlib.context import CryptContext

SECRET_KEY = "CHANGE_THIS_LATER"
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60

# IMPORTANT: use PBKDF2 instead of bcrypt (Python 3.12 safe)
pwd_context = CryptContext(
    schemes=["pbkdf2_sha256"],
    deprecated="auto"
)


def hash_password(password: str) -> str:
    return pwd_context.hash(password)


def verify_password(password: str, hashed_password: str) -> bool:
    return pwd_context.verify(password, hashed_password)


def create_access_token(data: dict):
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    return jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)

dependencies.py:
from fastapi import Depends, HTTPException
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from sqlalchemy.orm import Session

from app.db.database import SessionLocal
from app.db.models import User
from app.auth.auth_utils import SECRET_KEY, ALGORITHM

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/login")


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: Session = Depends(get_db),
) -> User:
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str | None = payload.get("user_id")

        if user_id is None:
            raise HTTPException(status_code=401, detail="Invalid token")

    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")

    user = db.query(User).filter(User.id == user_id).first()

    if not user:
        raise HTTPException(status_code=401, detail="User not found")

    return user

google_auth.py:
from fastapi import APIRouter, Request
from fastapi.responses import RedirectResponse
from google_auth_oauthlib.flow import Flow
import os
from sqlalchemy.orm import Session
from fastapi import Depends
from app.db.database import SessionLocal
from app.db.models import User, GoogleCredential
from datetime import datetime
import requests
from app.auth.auth_utils import create_access_token



router = APIRouter(prefix="/auth/google", tags=["google-auth"])

CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")
REDIRECT_URI = os.getenv("GOOGLE_REDIRECT_URI")


SCOPES = [
    "https://www.googleapis.com/auth/gmail.readonly",
    "https://www.googleapis.com/auth/calendar", 
    "https://www.googleapis.com/auth/userinfo.email",
    "openid",
]



@router.get("/login")
def google_login():
    flow = Flow.from_client_config(
        {
            "web": {
                "client_id": CLIENT_ID,
                "client_secret": CLIENT_SECRET,
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
            }
        },
        scopes=SCOPES,
        redirect_uri=REDIRECT_URI,
    )

    auth_url, _ = flow.authorization_url(
        access_type="offline",
        include_granted_scopes="true",
        prompt="consent",
    )

    return RedirectResponse(auth_url)


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@router.get("/callback")
def google_callback(request: Request, db: Session = Depends(get_db)):
    code = request.query_params.get("code")

    flow = Flow.from_client_config(
        {
            "web": {
                "client_id": CLIENT_ID,
                "client_secret": CLIENT_SECRET,
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
            }
        },
        scopes=SCOPES,
        redirect_uri=REDIRECT_URI,
    )

    # 1. Exchange code for tokens
    flow.fetch_token(code=code)
    credentials = flow.credentials
    userinfo_response = requests.get(
        "https://www.googleapis.com/oauth2/v2/userinfo",
        headers={"Authorization": f"Bearer {credentials.token}"}
    )

    userinfo = userinfo_response.json()
    email = userinfo.get("email")
    user = db.query(User).filter(User.email == email).first()

    if not user:
        user = User(email=email)
        db.add(user)
        db.commit()
        db.refresh(user)
    expires_at = credentials.expiry

    google_creds = db.query(GoogleCredential).filter(
        GoogleCredential.user_id == user.id
    ).first()

    if not google_creds:
        google_creds = GoogleCredential(
            user_id=user.id,
            access_token=credentials.token,
            refresh_token=credentials.refresh_token,
            expires_at=expires_at,
            scopes=" ".join(credentials.scopes)
        )
        db.add(google_creds)
    else:
        google_creds.access_token = credentials.token
        google_creds.expires_at = expires_at

    db.commit()
    
    app_token = create_access_token({"user_id": str(user.id)})

    return {
        "message": "Google OAuth successful",
        "access_token": app_token,
        "token_type": "bearer"
    }


@router.get("/calendar-consent")
def google_calendar_consent():
    flow = Flow.from_client_config(
        {
            "web": {
                "client_id": CLIENT_ID,
                "client_secret": CLIENT_SECRET,
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
            }
        },
        scopes=SCOPES,
        redirect_uri=REDIRECT_URI,  # SAME callback
    )

    auth_url, _ = flow.authorization_url(
        access_type="offline",
        prompt="consent",
        include_granted_scopes="true",
    )

    return RedirectResponse(auth_url)

routes.py:
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session
from app.db.database import SessionLocal
from app.db.models import User
from app.auth.schemas import UserCreate, Token
from app.auth.auth_utils import hash_password, verify_password, create_access_token

router = APIRouter(prefix="/auth", tags=["auth"])


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


@router.post("/register", response_model=Token)
def register(user: UserCreate, db: Session = Depends(get_db)):
    existing_user = db.query(User).filter(User.email == user.email).first()
    if existing_user:
        raise HTTPException(status_code=400, detail="User already exists")

    new_user = User(
        email=user.email,
        hashed_password=hash_password(user.password)
    )
    db.add(new_user)
    db.commit()
    db.refresh(new_user)

    token = create_access_token({"user_id": new_user.id})
    return {"access_token": token}


@router.post("/login", response_model=Token)
def login(user: UserCreate, db: Session = Depends(get_db)):
    db_user = db.query(User).filter(User.email == user.email).first()
    if not db_user or not verify_password(user.password, db_user.hashed_password):
        raise HTTPException(status_code=401, detail="Invalid credentials")

    token = create_access_token({"user_id": db_user.id})
    return {"access_token": token}

schemas.py:
from pydantic import BaseModel, EmailStr


class UserCreate(BaseModel):
    email: EmailStr
    password: str


class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"

/core
config.py:
from dotenv import load_dotenv
import os

load_dotenv()

APP_NAME = os.getenv("APP_NAME", "App")


GOOGLE_CLIENT_ID = os.getenv("GOOGLE_CLIENT_ID")
GOOGLE_CLIENT_SECRET = os.getenv("GOOGLE_CLIENT_SECRET")


/db:
database.py:
import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base

# Use environment variable or default to psycopg (v3) driver
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql+psycopg://postgres:password@localhost:5432/chief_of_staff")

# Convert Railway/standard PostgreSQL URLs to psycopg v3 format
if DATABASE_URL:
    # Convert postgresql:// to postgresql+psycopg://
    DATABASE_URL = DATABASE_URL.replace("postgresql://", "postgresql+psycopg://")
    # Also handle psycopg2 if present
    DATABASE_URL = DATABASE_URL.replace("postgresql+psycopg2://", "postgresql+psycopg://")

engine = create_engine(DATABASE_URL)

SessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine
)

Base = declarative_base()

models.py:

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey
from datetime import datetime
from app.db.database import Base
from sqlalchemy.dialects.postgresql import UUID
import uuid

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String, unique=True, index=True, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)

class GoogleCredential(Base):
    __tablename__ = "google_credentials"

    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), primary_key=True)

    access_token = Column(String, nullable=False)
    refresh_token = Column(String, nullable=False)
    expires_at = Column(DateTime, nullable=False)
    scopes = Column(String)

    updated_at = Column(DateTime, default=datetime.utcnow)


class Message(Base):
    __tablename__ = "messages"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))
    role = Column(String)  # user | assistant
    content = Column(String)
    created_at = Column(DateTime, default=datetime.utcnow)


class Memory(Base):
    __tablename__ = "memory"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"))
    key = Column(String)
    value = Column(String)
    source = Column(String)  # chat | email

/integrations
gmails.py:
from googleapiclient.discovery import build
from google.oauth2.credentials import Credentials
from googleapiclient.errors import HttpError


def get_gmail_service(access_token: str):
    creds = Credentials(
        token=access_token,
        scopes=["https://www.googleapis.com/auth/gmail.readonly"]
    )
    return build("gmail", "v1", credentials=creds)


def fetch_latest_emails(access_token: str, max_results: int = 5):
    try:
        service = get_gmail_service(access_token)

        results = service.users().messages().list(
            userId="me",
            maxResults=max_results
        ).execute()

        messages = results.get("messages", [])
        emails = []

        for msg in messages:
            msg_data = service.users().messages().get(
                userId="me",
                id=msg["id"],
                format="metadata",
                metadataHeaders=["From", "Subject"]
            ).execute()

            headers = msg_data.get("payload", {}).get("headers", [])
            email = {h["name"]: h["value"] for h in headers}
            emails.append(email)

        return emails

    except HttpError as e:
        # Google API error (most likely)
        raise RuntimeError(f"Gmail API error: {e}")

    except Exception as e:
        # Anything else
        raise RuntimeError(f"Unexpected Gmail error: {e}")

google_credentials.py:
from datetime import datetime
from google.oauth2.credentials import Credentials
from google.auth.transport.requests import Request
from sqlalchemy.orm import Session

from app.db.models import GoogleCredential
from app.core.config import (
    GOOGLE_CLIENT_ID,
    GOOGLE_CLIENT_SECRET
)


def get_valid_google_credentials(
    user_id,
    db: Session,
    required_scopes: list[str]
) -> Credentials:
    """
    Returns a valid Google Credentials object.
    Automatically refreshes the access token if expired.
    """

    # 1. Load stored credentials from DB
    creds_row = (
        db.query(GoogleCredential)
        .filter(GoogleCredential.user_id == user_id)
        .first()
    )

    if not creds_row:
        raise Exception("Google credentials not found for user")

    # 2. Build Credentials object
    credentials = Credentials(
        token=creds_row.access_token,
        refresh_token=creds_row.refresh_token,
        token_uri="https://oauth2.googleapis.com/token",
        client_id=GOOGLE_CLIENT_ID,
        client_secret=GOOGLE_CLIENT_SECRET,
        scopes=required_scopes
    )

    # 3. Check expiry and refresh if needed
    if credentials.expired:
        credentials.refresh(Request())

        # 4. Save updated token back to DB
        creds_row.access_token = credentials.token
        creds_row.expires_at = credentials.expiry
        creds_row.updated_at = datetime.utcnow()

        db.commit()

    return credentials


/tools:
calender_read_node:
from datetime import datetime, timedelta
from googleapiclient.discovery import build
from sqlalchemy.orm import Session

from app.integrations.google_credentials import get_valid_google_credentials


def fetch_upcoming_events(
    *,
    user_id,
    db: Session,
    max_results: int = 10
):
    """
    Fetch upcoming Google Calendar events for a user.
    """

    creds = get_valid_google_credentials(
        user_id=user_id,
        db=db,
        required_scopes=[
            "https://www.googleapis.com/auth/calendar.readonly"
        ]
    )

    service = build("calendar", "v3", credentials=creds)

    now = datetime.utcnow().isoformat() + "Z"
    one_week = (datetime.utcnow() + timedelta(days=7)).isoformat() + "Z"

    events_result = service.events().list(
        calendarId="primary",
        timeMin=now,
        timeMax=one_week,
        maxResults=max_results,
        singleEvents=True,
        orderBy="startTime"
    ).execute()

    events = events_result.get("items", [])

    parsed_events = []
    for event in events:
        parsed_events.append({
            "summary": event.get("summary"),
            "start": event.get("start"),
            "end": event.get("end")
        })

    return parsed_events

calander_write_tool.py:
from googleapiclient.discovery import build
from sqlalchemy.orm import Session
from datetime import datetime

from app.integrations.google_credentials import get_valid_google_credentials


def create_calendar_event(
    *,
    user_id,
    db: Session,
    title: str,
    start_time: datetime,
    end_time: datetime,
):
    """
    Create a Google Calendar event for the user.
    """

    creds = get_valid_google_credentials(
        user_id=user_id,
        db=db,
        required_scopes=[
            "https://www.googleapis.com/auth/calendar"
        ]
    )

    service = build("calendar", "v3", credentials=creds)

    event = {
        "summary": title,
        "start": {
            "dateTime": start_time.isoformat(),
            "timeZone": "UTC",
        },
        "end": {
            "dateTime": end_time.isoformat(),
            "timeZone": "UTC",
        },
    }

    created_event = service.events().insert(
        calendarId="primary",
        body=event
    ).execute()

    return {
        "id": created_event.get("id"),
        "summary": created_event.get("summary"),
        "htmlLink": created_event.get("htmlLink"),
    }

gmail_read_tool.py:
from datetime import datetime, timedelta, timezone
from googleapiclient.discovery import build
from sqlalchemy.orm import Session

from app.integrations.google_credentials import get_valid_google_credentials


def fetch_gmail_messages_for_date(
    *,
    user_id: str,
    db: Session,
    days_ago: int = 0,
    max_results: int = 10
):
    """
    Fetch Gmail messages for a specific day.
    days_ago = 0 â†’ today
    days_ago = 1 â†’ yesterday
    """

    creds = get_valid_google_credentials(
        user_id=user_id,
        db=db,
        required_scopes=[
            "https://www.googleapis.com/auth/gmail.readonly"
        ]
    )

    service = build("gmail", "v1", credentials=creds)

    now = datetime.now(timezone.utc)
    start = (now - timedelta(days=days_ago)).replace(
        hour=0, minute=0, second=0, microsecond=0
    )
    end = start + timedelta(days=1)

    query = (
        f"after:{int(start.timestamp())} "
        f"before:{int(end.timestamp())}"
    )

    results = service.users().messages().list(
        userId="me",
        q=query,
        maxResults=max_results
    ).execute()

    messages = results.get("messages", [])
    emails = []

    for msg in messages:
        data = service.users().messages().get(
            userId="me",
            id=msg["id"],
            format="metadata",
            metadataHeaders=["From", "Subject"]
        ).execute()

        headers = {
            h["name"]: h["value"]
            for h in data["payload"]["headers"]
        }

        emails.append({
            "from": headers.get("From"),
            "subject": headers.get("Subject"),
        })

    return emails
gmail_tool.py:
from googleapiclient.discovery import build
from sqlalchemy.orm import Session

from app.integrations.google_credentials import get_valid_google_credentials


def fetch_latest_emails(
    *,
    user_id,
    db: Session,
    max_results: int = 5
):
    """
    Fetch latest Gmail messages for a user.
    """

    creds = get_valid_google_credentials(
        user_id=user_id,
        db=db,
        required_scopes=[
            "https://www.googleapis.com/auth/gmail.readonly"
        ]
    )

    service = build("gmail", "v1", credentials=creds)

    results = service.users().messages().list(
        userId="me",
        maxResults=max_results
    ).execute()

    messages = results.get("messages", [])
    emails = []

    for msg in messages:
        msg_data = service.users().messages().get(
            userId="me",
            id=msg["id"],
            format="metadata",
            metadataHeaders=["From", "Subject"]
        ).execute()

        headers = msg_data["payload"]["headers"]
        email = {h["name"]: h["value"] for h in headers}
        emails.append(email)

    return emails


main.py:
from fastapi import FastAPI
from app.core.config import APP_NAME
from app.db.database import engine
from app.db import models
from app.auth.routes import router as auth_router
from app.api.chat import router as chat_router
from app.auth.google_auth import router as google_auth_router
from app.api.gmail import router as gmail_router
from app.api.calendar import router as calendar_router

# Create tables on startup
models.Base.metadata.create_all(bind=engine)



app = FastAPI(title=APP_NAME)

app.include_router(auth_router)

app.include_router(chat_router)

app.include_router(google_auth_router)

app.include_router(gmail_router)

app.include_router(calendar_router)


@app.get("/health")
def health_check():
    return {"status": "ok", "app": APP_NAME}

requirements.txt:
annotated-doc==0.0.4
annotated-types==0.7.0
anyio==4.12.1
bcrypt==5.0.0
certifi==2026.1.4
charset-normalizer==3.4.4
click==8.3.1
colorama==0.4.6
distro==1.9.0
dnspython==2.8.0
ecdsa==0.19.1
email-validator==2.3.0
fastapi==0.128.0
filelock==3.20.3
filetype==1.2.0
fsspec==2026.1.0
google-api-core==2.29.0
google-api-python-client==2.188.0
google-auth==2.47.0
google-auth-httplib2==0.3.0
google-auth-oauthlib==1.2.4
google-genai==1.59.0
googleapis-common-protos==1.72.0
greenlet==3.3.0
groq==0.37.1
h11==0.16.0
httpcore==1.0.9
httplib2==0.31.1
httpx==0.28.1
huggingface-hub==0.36.0
idna==3.11
Jinja2==3.1.6
jiter==0.12.0
jsonpatch==1.33
jsonpointer==3.0.0
langchain==1.2.6
langchain-core==1.2.7
langchain-google-genai==4.2.0
langchain-groq==1.1.1
langchain-huggingface==1.2.0
langchain-openai==1.1.7
langgraph==1.0.6
langgraph-checkpoint==4.0.0
langgraph-prebuilt==1.0.6
langgraph-sdk==0.3.3
langsmith==0.6.4
MarkupSafe==3.0.3
mpmath==1.3.0
networkx==3.6.1
numpy==2.4.1
oauthlib==3.3.1
openai==2.15.0
orjson==3.11.5
ormsgpack==1.12.1
packaging==25.0
passlib==1.7.4
proto-plus==1.27.0
protobuf==6.33.4
pyasn1==0.6.2
pyasn1_modules==0.4.2
pydantic==2.12.5
pydantic_core==2.41.5
pyparsing==3.3.1
python-dotenv==1.2.1
python-jose==3.5.0
python-multipart==0.0.21
PyYAML==6.0.3
regex==2026.1.15
requests==2.32.5
requests-oauthlib==2.0.0
requests-toolbelt==1.0.0
rsa==4.9.1
safetensors==0.7.0
setuptools==80.9.0
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.45
psycopg[binary]==3.3.2
starlette==0.50.0
sympy==1.14.0
tenacity==9.1.2
tiktoken==0.12.0
tokenizers==0.22.2
torch==2.9.1
tqdm==4.67.1
transformers==4.57.6
typing-inspection==0.4.2
typing_extensions==4.15.0
uritemplate==4.2.0
urllib3==2.6.3
uuid_utils==0.13.0
uvicorn==0.40.0
websockets==15.0.1
xxhash==3.6.0
zstandard==0.25.0

.gitignore:
# Python
__pycache__/
*.pyc

# Virtual environments
venv/
backend/venv/

# HuggingFace cache
.cache/
hf_cache/

# Env files
.env

# OS junk
.DS_Store
Thumbs.db

# Databases
*.db
backend/*.db

